var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VTT_CHECK = /^WEBVTT/;
var VTT_STYLE = /^STYLE+$/;
// eslint-disable-next-line no-useless-escape
var VTT_CUE = /^\:\:cue/;
var VTT_CUEND = /^}+$/;
var ASS_CHECK = /^\[Script Info\].*/;

// const HTML_REGEX = /<[a-zA-Z]+.*?>([\s\S]*?)<\/[a-zA-Z]*?>/  匹配html标签

// String a1 = "[0-9]{4}[0-9]{2}[0-9]{2}[0-9]{2}[0-9]{2}[0-9]{2}";//yyyyMMddHHmmss
// String a2 = "[0-9]{4}[0-9]{2}[0-9]{2}";//yyyyMMdd
// String a3 = "[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}";//yyyy-MM-dd HH:mm:ss
// String a4 = "[0-9]{4}-[0-9]{2}-[0-9]{2}";//yyyy-MM-dd
// String a5= "[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}";
// const TIME_REGEX = /[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}-->[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}/

var TIME_REGEX_LIST = [/[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}-->[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}/, /[0-9]{2}:[0-9]{2}\.[0-9]{3}-->[0-9]{2}:[0-9]{2}\.[0-9]{3}/, /[0-9]{2}\.[0-9]{3}-->[0-9]{2}\.[0-9]{3}/];
// const LANG_REGEX = /^(<?.+?>(([\s\S])*?)<\/?.+?>)$/

var MAX_COUNT = 50;

var ASS_FORMAT = /^Format:\s/;
var ASS_STYLE = /^Style:\s/;
var ASS_DIALOGUE = /^Dialogue:\s/;
// const ASS_EVENTS = /^\[Events\]:\s/

function getSecond(arr) {
  var len = arr.length;
  if (len === 3) {
    return ((Number(arr[0]) * 60 + Number(arr[1])) * 60 * 1000 + Number(arr[2]) * 1000) / 1000;
  } else if (len === 2) {
    return (Number(arr[0]) * 60 * 1000 + Number(arr[1]) * 1000) / 1000;
  } else {
    return Number(arr[0]);
  }
}

/**
 * 校验是否是数字
 * @param {String} str
 */
function isNumber(str) {
  // eslint-disable-next-line no-useless-escape
  return (/^(\-|\+)?\d+(\.\d+)?$/.test(str)
  );
}

/**
 * 对html内容进行转义，避免使用innerHTML的时候出现DOM XSS漏洞
 * @param  {[type]} e [description]
 * @return {[type]}   [description]
 */
function htmlEncodeAll(e) {
  return e;
  // return null === e ? '' : e.replace(/\&/g, '&amp;').replace(/\</g, '&lt;').replace(/\>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
}

function getByIndex(i, arr) {
  if (i >= 0 && i < arr.length) {
    return arr[i];
  }
  return '';
}

var SubTitleParser = function () {
  function SubTitleParser() {
    _classCallCheck(this, SubTitleParser);
  }

  _createClass(SubTitleParser, null, [{
    key: 'parse',
    value: function parse(str, fun) {
      var format = SubTitleParser.checkFormat(str);
      if (!format) {
        fun({ format: format });
      }
      try {
        var ret = [];
        if (format === 'ass') {
          ret = SubTitleParser.parseASS(str);
        } else if (format === 'vtt') {
          ret = SubTitleParser.parseVTT(str);
        }
        fun({ format: format, list: ret.list, styles: ret.styles });
      } catch (error) {
        console.error(error);
        fun({ format: format }, error);
      }
    }
  }, {
    key: 'parseASSItem',
    value: function parseASSItem() {
      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var values = str.split(',');
      var item = {};
      var text = '';
      try {
        var len = values.length - mode.length;
        if (len > 0) {
          text = values.splice(mode.length - 1, len + 1).join(',') + '';
        } else {
          text = values[values.length - 1] + '';
        }
        text = text.replace(/\\n+/g, '');
        text = htmlEncodeAll(text);
        values[mode.length - 1] = text;
        mode.map(function (key, index) {
          if (key === 'end' || key === 'start') {
            item[key] = getSecond(values[index].split(':'));
          } else if (key === 'text') {
            item[key] = [values[index]];
          } else if (key === 'layer') {
            item[key] = [values[index]];
            item.textTag = [values[index]];
          } else if (key === 'style') {
            item[key] = [values[index]];
          } else {
            item[key] = Number(values[index]) ? Number(values[index]) : values[index];
          }
        });
        return item;
      } catch (error) {
        console.error(error);
        return {};
      }
    }
  }, {
    key: 'parseASS',
    value: function parseASS(str) {
      var arr = str.split('\n');
      var retData = [];
      var i = 0;var groupCount = 0;
      var styles = [];
      var mode = [];
      var lastSubTitle = null;
      while (i < arr.length) {
        if (ASS_FORMAT.test(arr[i])) {
          mode = arr[i].replace(ASS_FORMAT, '').replace(/\s+/g, '').split(',');
          mode = mode.map(function (item) {
            return item.toLocaleLowerCase();
          });
        } else if (ASS_STYLE.test(arr[i])) {
          styles.push(arr[i].replace(ASS_STYLE, '').replace(/\s+/g, ''));
        } else if (ASS_DIALOGUE.test(arr[i])) {
          var subTitle = SubTitleParser.parseASSItem(arr[i].replace(ASS_DIALOGUE, ''), mode);
          if (!lastSubTitle || !(subTitle.start === lastSubTitle.start && subTitle.end === lastSubTitle.end)) {
            lastSubTitle = subTitle;
            var group = null;
            if (groupCount % MAX_COUNT === 0) {
              group = {
                start: lastSubTitle.start,
                end: lastSubTitle.end,
                list: []
              };
              group.list.push(lastSubTitle);
              retData.push(group);
            } else {
              group = retData[retData.length - 1];
              group.end = lastSubTitle.end;
              group.list.push(lastSubTitle);
            }
            groupCount++;
          } else {
            try {
              var _lastSubTitle = lastSubTitle,
                  text = _lastSubTitle.text,
                  textTag = _lastSubTitle.textTag,
                  style = _lastSubTitle.style;

              text.push(subTitle.text[0]);
              textTag.push(subTitle.textTag[0]);
              style.push(subTitle.style[0]);
            } catch (error) {
              console.error(error);
            }
          }
        }
        i++;
      }
      return {
        list: retData,
        style: {}
      };
    }
  }, {
    key: 'parseVTTStyle',
    value: function parseVTTStyle(str, style) {
      var arr = str.split(':');
      if (arr.length > 1) {
        var keyArr = arr[0].trim().split('-');
        var key = '';
        if (keyArr.length > 1) {
          keyArr.map(function (item, index) {
            key += index === 0 ? item : item.charAt(0).toUpperCase() + item.slice(1);
          });
        } else {
          key = keyArr[0];
        }
        style[key] = arr[1].trim().replace(/;$/, '');
      }
      return style;
    }
  }, {
    key: 'parseVTT',
    value: function parseVTT(str) {
      str = str.replace(VTT_CHECK, '');
      var arr = str.split('\n');
      var retData = [];
      var i = 0;
      var groupCount = 0;
      var lastSubTitle = null;
      // let lastTime = null
      var isLastSpace = false;
      var isCueStart = false;
      var styleInfo = null;
      var styleHeader = null;
      var styles = [];
      while (i < arr.length) {
        var _str = getByIndex(i, arr).trim();
        if (!_str || isLastSpace && isNumber(_str)) {
          isLastSpace = !_str;
        } else if (VTT_CUE.test(_str) && VTT_STYLE.test(getByIndex(i - 1, arr).trim())) {
          isCueStart = true;
          var cueMatch = /\((.+?)\)/g.exec(_str);
          if (!cueMatch) {
            styleHeader = '';
          } else {
            styleHeader = cueMatch[1];
          }
          styleInfo = '';
        } else if (isCueStart) {
          if (VTT_CUEND.test(_str)) {
            styles.push({
              key: styleHeader,
              style: styleInfo
            });
            styleInfo = null;
            styleHeader = null;
            isCueStart = false;
          } else {
            // console.log('parseVTTStyle', str)
            // this.parseVTTStyle(str, styles)
            styleInfo += _str;
          }
        } else if (_str) {
          isLastSpace = false;
          var time = this.checkIsTime(arr[i]);
          if (time) {
            var subTitle = this.parseVttTime(time);
            if (!lastSubTitle || !(subTitle.start === lastSubTitle.start && subTitle.end === lastSubTitle.end)) {
              lastSubTitle = subTitle;
              lastSubTitle.text = [];
              lastSubTitle.textTag = [];
              var group = null;
              if (groupCount % MAX_COUNT === 0) {
                group = {
                  start: lastSubTitle.start,
                  end: lastSubTitle.end,
                  list: []
                };
                group.list.push(lastSubTitle);
                retData.push(group);
              } else {
                group = retData[retData.length - 1];
                group.end = lastSubTitle.end;
                group.list.push(lastSubTitle);
              }
              groupCount++;
            }
          } else {
            if (lastSubTitle) {
              var _lastSubTitle2 = lastSubTitle,
                  text = _lastSubTitle2.text,
                  textTag = _lastSubTitle2.textTag;

              var ret = this.parseVttText(arr[i]);
              /**
                           * 兼容多种方式的多语言字幕
                           * demo1 每个语言独立时间标记
                           * =============================
                           * 00:00:06.470 --> 00:00:06.890
                           * Hello,
                           * 00:00:06.470 --> 00:00:06.890
                           * 你好，
                           * =============================
                           *
                           * demo2 多个语言公用一个时间标记，由尖括号组成的tag包裹
                           * =============================
                           * <cmn-Hans-CN>你好，</cmn-Hans-CN>
                           * <eng-US>hello,</eng-US>
                           * =============================
                           */
              // if (textTag.length === 0 || lastTime || (ret.tag && ret.tag !== textTag[textTag.length - 1])) {
              //   text.push(ret.text)
              //   textTag.push(ret.tag)
              // } else {
              //   text[textTag.length - 1] += ret.text
              // }
              text.push(ret.text);
              textTag.push(ret.tag);
            }
          }
          // lastTime = time
          isLastSpace = false;
        }
        i++;
        continue;
      }
      return {
        list: retData,
        styles: styles
      };
    }
  }, {
    key: 'checkIsTime',
    value: function checkIsTime(str) {
      str = str.replace(/\s+/g, '');
      var i = 0;
      var match = null;
      while (i < TIME_REGEX_LIST.length) {
        match = TIME_REGEX_LIST[i].exec(str);
        if (match) {
          break;
        }
        i++;
      }
      return match ? match[0] : null;
    }
  }, {
    key: 'parseVttText',
    value: function parseVttText(text) {
      // 检测是否有语言标记包裹
      var langMatch = /^(<?.+?>)/g.exec(text);
      var retText = '';var tag = 'default';
      if (langMatch) {
        // eslint-disable-next-line no-useless-escape
        tag = langMatch[0].replace(/\<|\>|\&/g, '');
        // 动态构造语言匹配规则
        // eslint-disable-next-line no-useless-escape
        var newReg = RegExp('^<' + tag + '>(([\\s\\S])*?)</' + tag + '>$');
        var textMatch = newReg.exec(text);
        if (textMatch) {
          retText = textMatch[1];
        } else {
          retText = text;
          tag = '';
        }
      } else {
        retText = text;
      }
      var tagsReg = /<(\w+).(\w+)>/g;
      var re = tagsReg.exec(retText);
      // console.log(' re[0]', re)
      while (re && re.length > 2) {
        // const tags = re[0].split('.')
        retText = retText.replace(re[0], '<' + re[1] + ' class="' + re[2] + '">');
        re = tagsReg.exec(retText);
      }
      return {
        tag: tag,
        text: htmlEncodeAll(retText.replace(/\\n+/g, '<br/>'))
      };
    }
  }, {
    key: 'parseVttTime',
    value: function parseVttTime(str) {
      var arr = str.split('-->');
      var start = void 0;var end = 0;
      if (arr.length === 2) {
        var aArr = arr[0].split(':');
        var bArr = arr[1].split(':');
        start = getSecond(aArr);
        end = getSecond(bArr);
      }
      return {
        start: start,
        end: end,
        time: str
      };
    }
  }, {
    key: 'isVTT',
    value: function isVTT(str) {
      return VTT_CHECK.test(str);
    }
  }, {
    key: 'isASS',
    value: function isASS(str) {
      return ASS_CHECK.test(str);
    }
  }, {
    key: 'checkFormat',
    value: function checkFormat(str) {
      if (!str) {
        return null;
      }
      if (VTT_CHECK.test(str)) {
        return 'vtt';
      } else if (ASS_CHECK.test(str)) {
        return 'ass';
      }
      return null;
    }
  }]);

  return SubTitleParser;
}();

export default SubTitleParser;